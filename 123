-- Bundled cable control with button grid UI
-- Works with advanced computer + 5x2 monitor
-- Make sure monitor is attached on "right", change if needed

local monitor = peripheral.wrap("right")
local colors = colors -- shorthand

-- Define channels (bundled colors)
local channels = {
    {name = "Blaze", color = colors.red},
    {name = "Wither", color = colors.blue},
    {name = "Creeper", color = colors.green},
    {name = "Iron Golem", color = colors.yellow},
    {name = "Witch", color = colors.purple},
    {name = "Piglin", color = colors.orange},
    {name = "Others 1", color = colors.cyan},
    {name = "Others 2", color = colors.lime},
    {name = "Others 3", color = colors.gray},
    {name = "Light", color = colors.white}
}

-- State storage
local states = {}
for _, c in ipairs(channels) do
    states[c.name] = false
end

-- Output bundled signals
local function updateOutputs()
    local out = 0
    for _, c in ipairs(channels) do
        if states[c.name] then
            out = colors.combine(out, c.color)
        end
    end
    redstone.setBundledOutput("back", out) -- change side if needed
end

-- Button positions (grid layout)
local buttonGrid = {}
local cols, rows = 2, 5  -- 2 columns, 5 rows
local boxW, boxH = 14, 3 -- button width & height

local function setupGrid()
    local i = 1
    for r = 1, rows do
        for c = 1, cols do
            if channels[i] then
                local x1 = (c - 1) * (boxW + 2) + 2
                local y1 = (r - 1) * (boxH + 1) + 2
                local x2 = x1 + boxW - 1
                local y2 = y1 + boxH - 1
                buttonGrid[i] = {x1=x1, y1=y1, x2=x2, y2=y2, name=channels[i].name}
                i = i + 1
            end
        end
    end
end

-- Draw buttons
local function drawUI()
    monitor.setBackgroundColor(colors.black)
    monitor.clear()
    monitor.setTextScale(0.5)

    for i, btn in ipairs(buttonGrid) do
        local c = channels[i]
        local active = states[c.name]

        if active then
            monitor.setBackgroundColor(colors.green)
        else
            monitor.setBackgroundColor(colors.red)
        end

        for y = btn.y1, btn.y2 do
            monitor.setCursorPos(btn.x1, y)
            monitor.write(string.rep(" ", boxW))
        end

        -- Centered label
        monitor.setCursorPos(btn.x1 + 2, btn.y1 + 1)
        monitor.setTextColor(colors.white)
        monitor.write(c.name)
    end
    monitor.setBackgroundColor(colors.black)
end

-- Find which button was touched
local function getButtonAt(x, y)
    for i, btn in ipairs(buttonGrid) do
        if x >= btn.x1 and x <= btn.x2 and y >= btn.y1 and y <= btn.y2 then
            return i
        end
    end
    return nil
end

-- Main loop
setupGrid()
drawUI()
while true do
    local e, side, x, y = os.pullEvent("monitor_touch")
    local i = getButtonAt(x, y)
    if i then
        local c = channels[i]
        states[c.name] = not states[c.name]
        updateOutputs()
        drawUI()
    end
end
